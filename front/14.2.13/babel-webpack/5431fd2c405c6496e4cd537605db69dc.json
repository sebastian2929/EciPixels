{"ast":null,"code":"import _asyncToGenerator from \"C:/kmi/Dropbox/pro/matrix/front/matrix/node_modules/@babel/runtime/helpers/esm/asyncToGenerator.js\";\nimport * as i0 from \"@angular/core\";\nimport * as i1 from \"../../services/websocket.service\";\nimport * as i2 from \"@angular/common\";\nimport * as i3 from \"@angular/forms\";\n\nfunction MatrixComponent_tr_23_td_1_Template(rf, ctx) {\n  if (rf & 1) {\n    const _r8 = i0.ɵɵgetCurrentView();\n\n    i0.ɵɵelementStart(0, \"td\", 9);\n    i0.ɵɵlistener(\"click\", function MatrixComponent_tr_23_td_1_Template_td_click_0_listener() {\n      const restoredCtx = i0.ɵɵrestoreView(_r8);\n      const j_r5 = restoredCtx.index;\n      const i_r2 = i0.ɵɵnextContext().index;\n      const ctx_r6 = i0.ɵɵnextContext();\n      return i0.ɵɵresetView(ctx_r6.setActiveCell(i_r2, j_r5));\n    });\n    i0.ɵɵtext(1);\n    i0.ɵɵelementEnd();\n  }\n\n  if (rf & 2) {\n    const cell_r4 = ctx.$implicit;\n    const j_r5 = ctx.index;\n    const i_r2 = i0.ɵɵnextContext().index;\n    const ctx_r3 = i0.ɵɵnextContext();\n    i0.ɵɵstyleProp(\"background-color\", ctx_r3.isActiveCell(i_r2, j_r5) ? ctx_r3.getCellColor(ctx_r3.pla) : ctx_r3.getCellColor(cell_r4 == null ? null : cell_r4.player))(\"border\", ctx_r3.isActiveCell(i_r2, j_r5) ? \"2px solid yellow\" : \"\");\n    i0.ɵɵadvance(1);\n    i0.ɵɵtextInterpolate1(\" \", cell_r4 == null ? null : cell_r4.player, \" \");\n  }\n}\n\nfunction MatrixComponent_tr_23_Template(rf, ctx) {\n  if (rf & 1) {\n    i0.ɵɵelementStart(0, \"tr\");\n    i0.ɵɵtemplate(1, MatrixComponent_tr_23_td_1_Template, 2, 5, \"td\", 8);\n    i0.ɵɵelementEnd();\n  }\n\n  if (rf & 2) {\n    const row_r1 = ctx.$implicit;\n    i0.ɵɵadvance(1);\n    i0.ɵɵproperty(\"ngForOf\", row_r1);\n  }\n}\n\nexport class MatrixComponent {\n  constructor(websocketService) {\n    this.websocketService = websocketService; // Declarar propiedades y métodos según sea necesario\n\n    this.rows = 60; // Fila para la celda a actualizar\n\n    this.cols = 60; // Columna para la celda a actualizar\n\n    this.matrix = []; // Matriz para almacenar los datos recibidos del servidor\n\n    this.row = 0; // Fila para la celda a actualizar\n\n    this.col = 0; // Columna para la celda a actualizar\n\n    this.val = 0; // Valor para la celda a actualizar\n\n    this.pla = 3; // Jugador para la celda a actualizar\n    // Otros métodos y funciones según sea necesario\n    // Front\n    // Variables para almacenar la posición activa\n\n    this.activeCell = null;\n    this.visitedCells = [];\n    this.isEnabled = true;\n    this.debounceTimeout = null;\n  }\n\n  ngOnInit() {\n    // Configurar la conexión WebSocket al iniciar el componente\n    this.setupWebSocket(); // Solicitar la matriz al servidor al iniciar el componente\n\n    this.getMatrixValue();\n  } // Método para configurar la conexión WebSocket\n\n\n  setupWebSocket() {\n    const socket = this.websocketService.getMessage();\n    socket.subscribe(message => {\n      // Manejar los mensajes entrantes del servidor\n      this.handleIncomingMessage(message);\n    });\n  } // Método para manejar los mensajes entrantes del servidor\n  //\n  //\n\n\n  handleIncomingMessage(message) {\n    // Actualizar la matriz si se recibe un mensaje de actualización de matriz\n    if (message.action === 'updateMatrix') {\n      //Actualizar la matriz con los nuevos datos recibidos del servidor\n      this.matrix = message.data.matrix;\n    } // Otros tipos de mensajes pueden ser manejados aquí según las necesidades de la aplicación\n\n  } // Método para solicitar la matriz al servidor\n\n\n  getMatrixValue() {\n    this.websocketService.sendMessage('getMatrix', {});\n  } // Método para actualizar una celda en la matriz\n\n\n  updateCell(row, column, player, value) {\n    // Enviar un mensaje al servidor WebSocket (Controlador) para actualizar la celda\n    this.websocketService.sendMessage('updCell', {\n      row,\n      column,\n      player,\n      value\n    });\n  } // Método para actualizar VARIAS celda en la matrix cuando un juagador gana o pierde\n\n\n  updateCellsByPlayer(player, value, row, column) {\n    this.websocketService.sendMessage('updateCellsByPlayer', {\n      player,\n      value,\n      row,\n      column\n    });\n  } // Métodos que permiten \n  // cambia el color de acuerdocon el jugador que esté jugando\n\n\n  getCellColor(player) {\n    switch (player + '') {\n      case '1':\n        return 'blue';\n\n      case '2':\n        return 'red';\n\n      case '3':\n        return 'green';\n\n      case '4':\n        return 'gray';\n\n      default:\n        return 'lightblue';\n    }\n  }\n\n  handleKeyDown(event) {\n    var _this = this;\n\n    return _asyncToGenerator(function* () {\n      if (_this.isEnabled) {\n        // Cancela el timeout anterior si existe\n        if (_this.debounceTimeout) {\n          clearTimeout(_this.debounceTimeout);\n        }\n\n        _this.debounceTimeout = setTimeout(() => {\n          let {\n            row,\n            col\n          } = _this.activeCell || {\n            row: 0,\n            col: 0\n          };\n\n          switch (event.key) {\n            case 'ArrowUp':\n              row = Math.max(-1, row - 1);\n              break;\n\n            case 'ArrowDown':\n              row = Math.min(_this.rows, row + 1);\n              break;\n\n            case 'ArrowLeft':\n              col = Math.max(-1, col - 1);\n              break;\n\n            case 'ArrowRight':\n              col = Math.min(_this.cols, col + 1);\n              break;\n\n            default:\n              return;\n          }\n\n          if (row >= _this.rows || col >= _this.cols || row < 0 || col < 0) {\n            _this.isEnabled = false;\n\n            _this.updateCellsByPlayer(_this.pla, null, _this.rows, _this.cols);\n          } else {\n            _this.setActiveCell(row, col);\n          }\n        }, 20); // Espera 200ms antes de ejecutar el código\n      }\n    })();\n  }\n\n  setActiveCell(row, col) {\n    this.activeCell = {\n      row,\n      col\n    };\n    this.visitedCells.push({\n      row,\n      col\n    });\n    this.updateCell(row, col, this.pla, 0);\n  }\n\n  isActiveCell(row, col) {\n    return this.activeCell?.row === row && this.activeCell?.col === col;\n  } // Otros métodos de prueba que se construyeron\n  // Método asincrónico para obtener el valor de una celda desde el servidor\n\n\n  getCellPlayer(row, column) {\n    var _this2 = this;\n\n    return _asyncToGenerator(function* () {\n      try {\n        const cellPlayer = yield _this2.websocketService.sendMessage('getCellPlayer', {\n          row,\n          column\n        }); //console.log('Valor de la celda:', cellValue);\n\n        return cellPlayer;\n      } catch (error) {\n        console.error('Error obteniendo el valor de la celda:', error); // Aquí puedes manejar el error como desees\n\n        return null;\n      }\n    })();\n  } // Método para crear una nueva matriz en el servidor\n\n\n  createMatrix(row, column) {\n    // Enviar un mensaje al servidor WebSocket para crear la matriz\n    this.websocketService.sendMessage('createMatrix', {\n      row,\n      column\n    });\n  } // Método para DROP una nueva matriz en el servidor\n\n\n  dropMatrix(row, column) {\n    // Enviar un mensaje al servidor WebSocket para DROP la matriz\n    this.websocketService.sendMessage('dropMatrix', {});\n  }\n\n}\n\nMatrixComponent.ɵfac = function MatrixComponent_Factory(t) {\n  return new (t || MatrixComponent)(i0.ɵɵdirectiveInject(i1.WebsocketService));\n};\n\nMatrixComponent.ɵcmp = /*@__PURE__*/i0.ɵɵdefineComponent({\n  type: MatrixComponent,\n  selectors: [[\"app-matrix\"]],\n  decls: 24,\n  vars: 5,\n  consts: [[1, \"update-cell-form\"], [\"type\", \"number\", \"placeholder\", \"Fila\", 1, \"input-field\", 3, \"ngModel\", \"ngModelChange\"], [\"type\", \"number\", \"placeholder\", \"Columna\", 1, \"input-field\", 3, \"ngModel\", \"ngModelChange\"], [\"type\", \"text\", \"placeholder\", \"Nuevo valor\", 1, \"input-field\", 3, \"ngModel\", \"ngModelChange\"], [\"type\", \"text\", \"placeholder\", \"Jugador\", 1, \"input-field\", 3, \"ngModel\", \"ngModelChange\"], [1, \"update-button\", 3, \"click\"], [\"tabindex\", \"0\", 3, \"keydown\"], [4, \"ngFor\", \"ngForOf\"], [3, \"background-color\", \"border\", \"click\", 4, \"ngFor\", \"ngForOf\"], [3, \"click\"]],\n  template: function MatrixComponent_Template(rf, ctx) {\n    if (rf & 1) {\n      i0.ɵɵelementStart(0, \"div\", 0)(1, \"label\");\n      i0.ɵɵtext(2, \"Fila:\");\n      i0.ɵɵelementEnd();\n      i0.ɵɵelementStart(3, \"input\", 1);\n      i0.ɵɵlistener(\"ngModelChange\", function MatrixComponent_Template_input_ngModelChange_3_listener($event) {\n        return ctx.row = $event;\n      });\n      i0.ɵɵelementEnd();\n      i0.ɵɵelementStart(4, \"label\");\n      i0.ɵɵtext(5, \"Columna:\");\n      i0.ɵɵelementEnd();\n      i0.ɵɵelementStart(6, \"input\", 2);\n      i0.ɵɵlistener(\"ngModelChange\", function MatrixComponent_Template_input_ngModelChange_6_listener($event) {\n        return ctx.col = $event;\n      });\n      i0.ɵɵelementEnd();\n      i0.ɵɵelementStart(7, \"label\");\n      i0.ɵɵtext(8, \"Nuevo valor:\");\n      i0.ɵɵelementEnd();\n      i0.ɵɵelementStart(9, \"input\", 3);\n      i0.ɵɵlistener(\"ngModelChange\", function MatrixComponent_Template_input_ngModelChange_9_listener($event) {\n        return ctx.val = $event;\n      });\n      i0.ɵɵelementEnd();\n      i0.ɵɵelementStart(10, \"label\");\n      i0.ɵɵtext(11, \"Jugador:\");\n      i0.ɵɵelementEnd();\n      i0.ɵɵelementStart(12, \"input\", 4);\n      i0.ɵɵlistener(\"ngModelChange\", function MatrixComponent_Template_input_ngModelChange_12_listener($event) {\n        return ctx.pla = $event;\n      });\n      i0.ɵɵelementEnd();\n      i0.ɵɵelementStart(13, \"button\", 5);\n      i0.ɵɵlistener(\"click\", function MatrixComponent_Template_button_click_13_listener() {\n        return ctx.updateCell(ctx.row, ctx.col, ctx.pla, ctx.val);\n      });\n      i0.ɵɵtext(14, \"Actualizar Celda\");\n      i0.ɵɵelementEnd();\n      i0.ɵɵelementStart(15, \"button\", 5);\n      i0.ɵɵlistener(\"click\", function MatrixComponent_Template_button_click_15_listener() {\n        return ctx.getCellPlayer(ctx.row, ctx.col);\n      });\n      i0.ɵɵtext(16, \"Obtener valor\");\n      i0.ɵɵelementEnd();\n      i0.ɵɵelementStart(17, \"button\", 5);\n      i0.ɵɵlistener(\"click\", function MatrixComponent_Template_button_click_17_listener() {\n        return ctx.createMatrix(ctx.rows, ctx.cols);\n      });\n      i0.ɵɵtext(18, \"Crear matrix\");\n      i0.ɵɵelementEnd();\n      i0.ɵɵelementStart(19, \"button\", 5);\n      i0.ɵɵlistener(\"click\", function MatrixComponent_Template_button_click_19_listener() {\n        return ctx.dropMatrix(ctx.rows, ctx.cols);\n      });\n      i0.ɵɵtext(20, \"Borrar matrix\");\n      i0.ɵɵelementEnd()();\n      i0.ɵɵelement(21, \"br\");\n      i0.ɵɵelementStart(22, \"table\", 6);\n      i0.ɵɵlistener(\"keydown\", function MatrixComponent_Template_table_keydown_22_listener($event) {\n        return ctx.handleKeyDown($event);\n      });\n      i0.ɵɵtemplate(23, MatrixComponent_tr_23_Template, 2, 1, \"tr\", 7);\n      i0.ɵɵelementEnd();\n    }\n\n    if (rf & 2) {\n      i0.ɵɵadvance(3);\n      i0.ɵɵproperty(\"ngModel\", ctx.row);\n      i0.ɵɵadvance(3);\n      i0.ɵɵproperty(\"ngModel\", ctx.col);\n      i0.ɵɵadvance(3);\n      i0.ɵɵproperty(\"ngModel\", ctx.val);\n      i0.ɵɵadvance(3);\n      i0.ɵɵproperty(\"ngModel\", ctx.pla);\n      i0.ɵɵadvance(11);\n      i0.ɵɵproperty(\"ngForOf\", ctx.matrix);\n    }\n  },\n  dependencies: [i2.NgForOf, i3.DefaultValueAccessor, i3.NumberValueAccessor, i3.NgControlStatus, i3.NgModel],\n  styles: [\"table[_ngcontent-%COMP%] {\\r\\n    border-collapse: collapse;\\r\\n  }\\r\\n  \\r\\n  td[_ngcontent-%COMP%] {\\r\\n    width: 40px;  \\r\\n    height: 20px; \\r\\n    text-align: center;\\r\\n    vertical-align: middle;\\r\\n    border: 1px solid black;\\r\\n  }\\n/*# sourceMappingURL=data:application/json;base64,eyJ2ZXJzaW9uIjozLCJzb3VyY2VzIjpbIm1hdHJpeC5jb21wb25lbnQuY3NzIl0sIm5hbWVzIjpbXSwibWFwcGluZ3MiOiJFQUFFO0lBQ0UseUJBQXlCO0VBQzNCOztFQUVBO0lBQ0UsV0FBVyxHQUFHLHVCQUF1QjtJQUNyQyxZQUFZLEVBQUUsdUJBQXVCO0lBQ3JDLGtCQUFrQjtJQUNsQixzQkFBc0I7SUFDdEIsdUJBQXVCO0VBQ3pCIiwiZmlsZSI6Im1hdHJpeC5jb21wb25lbnQuY3NzIiwic291cmNlc0NvbnRlbnQiOlsiICB0YWJsZSB7XHJcbiAgICBib3JkZXItY29sbGFwc2U6IGNvbGxhcHNlO1xyXG4gIH1cclxuICBcclxuICB0ZCB7XHJcbiAgICB3aWR0aDogNDBweDsgIC8qIFRhbWHDsW8gZGUgbGEgY2VsZGEgKi9cclxuICAgIGhlaWdodDogMjBweDsgLyogVGFtYcOxbyBkZSBsYSBjZWxkYSAqL1xyXG4gICAgdGV4dC1hbGlnbjogY2VudGVyO1xyXG4gICAgdmVydGljYWwtYWxpZ246IG1pZGRsZTtcclxuICAgIGJvcmRlcjogMXB4IHNvbGlkIGJsYWNrO1xyXG4gIH1cclxuICAiXX0= */\"]\n});","map":{"version":3,"mappings":"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","names":["i0","ctx_r3","MatrixComponent","constructor","websocketService","ngOnInit","setupWebSocket","getMatrixValue","socket","getMessage","subscribe","message","handleIncomingMessage","action","matrix","data","sendMessage","updateCell","row","column","player","value","updateCellsByPlayer","getCellColor","handleKeyDown","event","isEnabled","debounceTimeout","clearTimeout","setTimeout","col","activeCell","key","Math","max","min","rows","cols","pla","setActiveCell","visitedCells","push","isActiveCell","getCellPlayer","cellPlayer","error","console","createMatrix","dropMatrix","selectors","decls","vars","consts","template","ctx"],"sourceRoot":"","sources":["C:\\kmi\\Dropbox\\pro\\matrix\\front\\matrix\\src\\app\\components\\matrix\\matrix.component.html","C:\\kmi\\Dropbox\\pro\\matrix\\front\\matrix\\src\\app\\components\\matrix\\matrix.component.ts"],"sourcesContent":["\n<div class=\"update-cell-form\">\n  <label>Fila:</label>\n  <input class=\"input-field\" type=\"number\" placeholder=\"Fila\" [(ngModel)]=\"row\">\n  <label>Columna:</label>\n  <input class=\"input-field\" type=\"number\" placeholder=\"Columna\" [(ngModel)]=\"col\">\n  <label>Nuevo valor:</label>\n  <input class=\"input-field\" type=\"text\" placeholder=\"Nuevo valor\" [(ngModel)]=\"val\">\n  <label>Jugador:</label>\n  <input class=\"input-field\" type=\"text\" placeholder=\"Jugador\" [(ngModel)]=\"pla\">\n  <button class=\"update-button\" (click)=\"updateCell(row, col, pla, val)\">Actualizar Celda</button>\n  <button class=\"update-button\" (click)=\"getCellPlayer(row, col)\">Obtener valor</button>\n  <button class=\"update-button\" (click)=\"createMatrix(rows, cols)\">Crear matrix</button>\n  <button class=\"update-button\" (click)=\"dropMatrix(rows, cols)\">Borrar matrix</button>\n</div>\n<br>\n\n<table (keydown)=\"handleKeyDown($event)\" tabindex=\"0\">\n  <tr *ngFor=\"let row of matrix; let i = index\">\n    <td *ngFor=\"let cell of row; let j = index\"\n        [style.background-color]=\"isActiveCell(i, j) ? getCellColor(pla) : getCellColor(cell?.player)\"\n        [style.border]=\"isActiveCell(i, j) ? '2px solid yellow' : ''\"\n        (click)=\"setActiveCell(i, j)\">\n      {{ cell?.player }}\n    </td>\n  </tr>\n</table>\n\n","import { Component, OnInit } from '@angular/core';\nimport { WebsocketService } from '../../services/websocket.service';\n\n@Component({\n  selector: 'app-matrix',\n  templateUrl: './matrix.component.html',\n  styleUrls: ['./matrix.component.css']\n})\nexport class MatrixComponent implements OnInit {\n  // Declarar propiedades y métodos según sea necesario\n\n  rows: number = 60; // Fila para la celda a actualizar\n  cols: number = 60; // Columna para la celda a actualizar\n  matrix: any[][] = []; // Matriz para almacenar los datos recibidos del servidor\n  row: number = 0; // Fila para la celda a actualizar\n  col: number = 0; // Columna para la celda a actualizar\n  val: number = 0; // Valor para la celda a actualizar\n  pla: number = 3; // Jugador para la celda a actualizar\n\n\n\n  constructor(private websocketService: WebsocketService) { }\n\n  ngOnInit(): void {\n    // Configurar la conexión WebSocket al iniciar el componente\n    this.setupWebSocket();\n    // Solicitar la matriz al servidor al iniciar el componente\n    this.getMatrixValue();\n  }\n\n  // Método para configurar la conexión WebSocket\n  private setupWebSocket(): void {\n    const socket = this.websocketService.getMessage();\n    socket.subscribe((message) => {\n      // Manejar los mensajes entrantes del servidor\n      this.handleIncomingMessage(message);\n    });\n  }\n\n  // Método para manejar los mensajes entrantes del servidor\n  //\n  //\n  private handleIncomingMessage(message: any): void {\n    // Actualizar la matriz si se recibe un mensaje de actualización de matriz\n    if (message.action === 'updateMatrix') {\n      //Actualizar la matriz con los nuevos datos recibidos del servidor\n      this.matrix = message.data.matrix;\n    }\n\n    // Otros tipos de mensajes pueden ser manejados aquí según las necesidades de la aplicación\n  }\n\n\n  // Método para solicitar la matriz al servidor\n  getMatrixValue(): void {\n    this.websocketService.sendMessage('getMatrix', {});\n  }\n\n  // Método para actualizar una celda en la matriz\n  updateCell(row: number, column: number, player: number, value: number): void {\n    // Enviar un mensaje al servidor WebSocket (Controlador) para actualizar la celda\n    this.websocketService.sendMessage('updCell', { row, column, player, value });\n  }\n\n  // Método para actualizar VARIAS celda en la matrix cuando un juagador gana o pierde\n  updateCellsByPlayer(player: number, value: number | null, row: number, column: number) {\n    this.websocketService.sendMessage('updateCellsByPlayer', { player, value, row, column });\n  }\n\n\n\n\n\n  // Otros métodos y funciones según sea necesario\n  // Front\n  // Variables para almacenar la posición activa\n  activeCell: { row: number, col: number } | null = null;\n  visitedCells: { row: number, col: number }[] = [];\n  isEnabled: boolean = true;\n\n\n  // Métodos que permiten \n  // cambia el color de acuerdocon el jugador que esté jugando\n  getCellColor(player: number | null): any {\n    switch (player + '') {\n      case '1':\n        return 'blue';\n      case '2':\n        return 'red';\n      case '3':\n        return 'green';\n      case '4':\n        return 'gray';\n      default:\n        return 'lightblue';\n    }\n  }\n\n\n  private debounceTimeout: any = null;\n\nasync handleKeyDown(event: KeyboardEvent): Promise<void> {\n  if (this.isEnabled) {\n    // Cancela el timeout anterior si existe\n    if (this.debounceTimeout) {\n      clearTimeout(this.debounceTimeout);\n    }\n\n    this.debounceTimeout = setTimeout(() => {\n      let { row, col } = this.activeCell || { row: 0, col: 0 };\n      switch (event.key) {\n        case 'ArrowUp':\n          row = Math.max(-1, row - 1);\n          break;\n        case 'ArrowDown':\n          row = Math.min(this.rows, row + 1);\n          break;\n        case 'ArrowLeft':\n          col = Math.max(-1, col - 1);\n          break;\n        case 'ArrowRight':\n          col = Math.min(this.cols, col + 1);\n          break;\n        default:\n          return;\n      }\n\n      if (row >= this.rows || col >= this.cols || row < 0 || col < 0) {\n        this.isEnabled = false;\n        this.updateCellsByPlayer(this.pla, null, this.rows, this.cols);\n      } else {\n        this.setActiveCell(row, col);\n      }\n    }, 20); // Espera 200ms antes de ejecutar el código\n  }\n}\n\n\n  setActiveCell(row: number, col: number): void {\n    this.activeCell = { row, col };\n    this.visitedCells.push({ row, col });\n    this.updateCell(row, col, this.pla, 0);\n  }\n\n  isActiveCell(row: number, col: number): boolean {\n    return this.activeCell?.row === row && this.activeCell?.col === col;\n  }\n\n\n\n\n\n\n\n\n\n\n\n  // Otros métodos de prueba que se construyeron\n  // Método asincrónico para obtener el valor de una celda desde el servidor\n  async getCellPlayer(row: number, column: number): Promise<any> {\n    try {\n      const cellPlayer = await this.websocketService.sendMessage('getCellPlayer', { row, column });\n      //console.log('Valor de la celda:', cellValue);\n      return cellPlayer;\n    } catch (error) {\n      console.error('Error obteniendo el valor de la celda:', error);\n      // Aquí puedes manejar el error como desees\n      return null;\n    }\n  }\n\n  // Método para crear una nueva matriz en el servidor\n  createMatrix(row: number, column: number): void {\n    // Enviar un mensaje al servidor WebSocket para crear la matriz\n    this.websocketService.sendMessage('createMatrix', { row, column });\n  }\n\n  // Método para DROP una nueva matriz en el servidor\n  dropMatrix(row: number, column: number): void {\n    // Enviar un mensaje al servidor WebSocket para DROP la matriz\n    this.websocketService.sendMessage('dropMatrix', {});\n  }\n\n}\n"]},"metadata":{},"sourceType":"module"}