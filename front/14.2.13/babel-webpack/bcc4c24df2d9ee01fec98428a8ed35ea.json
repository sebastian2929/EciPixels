{"ast":null,"code":"import _asyncToGenerator from \"C:/kmi/Dropbox/pro/matrix - copia/front/matrix/node_modules/@babel/runtime/helpers/esm/asyncToGenerator.js\";\nimport * as i0 from \"@angular/core\";\nimport * as i1 from \"../../services/websocket.service\";\nimport * as i2 from \"@angular/common\";\nimport * as i3 from \"@angular/forms\";\n\nfunction MatrixComponent_div_15_div_1_Template(rf, ctx) {\n  if (rf & 1) {\n    const _r9 = i0.ɵɵgetCurrentView();\n\n    i0.ɵɵelementStart(0, \"div\", 9);\n    i0.ɵɵlistener(\"click\", function MatrixComponent_div_15_div_1_Template_div_click_0_listener() {\n      const restoredCtx = i0.ɵɵrestoreView(_r9);\n      const j_r6 = restoredCtx.index;\n      const i_r3 = i0.ɵɵnextContext().index;\n      const ctx_r7 = i0.ɵɵnextContext();\n      return i0.ɵɵresetView(ctx_r7.setActiveCell(i_r3, j_r6));\n    });\n    i0.ɵɵtext(1);\n    i0.ɵɵelementEnd();\n  }\n\n  if (rf & 2) {\n    const cell_r5 = ctx.$implicit;\n    const j_r6 = ctx.index;\n    const i_r3 = i0.ɵɵnextContext().index;\n    const ctx_r4 = i0.ɵɵnextContext();\n    i0.ɵɵstyleProp(\"left\", j_r6 * ctx_r4.sizebox + \"px\")(\"top\", i_r3 * ctx_r4.sizebox + \"px\")(\"background-color\", ctx_r4.isActiveCell(i_r3, j_r6) ? ctx_r4.getCellColor(ctx_r4.pla) : ctx_r4.getCellColor(cell_r5 == null ? null : cell_r5.player))(\"border\", ctx_r4.isActiveCell(i_r3, j_r6) ? \"2px solid yellow\" : \"\")(\"width\", ctx_r4.sizebox - 1, \"px\")(\"height\", ctx_r4.sizebox - 1, \"px\");\n    i0.ɵɵadvance(1);\n    i0.ɵɵtextInterpolate1(\" \", \"\", \" \");\n  }\n}\n\nfunction MatrixComponent_div_15_Template(rf, ctx) {\n  if (rf & 1) {\n    i0.ɵɵelementStart(0, \"div\");\n    i0.ɵɵtemplate(1, MatrixComponent_div_15_div_1_Template, 2, 13, \"div\", 8);\n    i0.ɵɵelementEnd();\n  }\n\n  if (rf & 2) {\n    const row_r2 = ctx.$implicit;\n    i0.ɵɵadvance(1);\n    i0.ɵɵproperty(\"ngForOf\", row_r2);\n  }\n}\n\nexport class MatrixComponent {\n  constructor(websocketService) {\n    this.websocketService = websocketService; // Declarar propiedades y métodos según sea necesario\n\n    this.rows = 60; // Fila para la celda a actualizar\n\n    this.cols = 60; // Columna para la celda a actualizar\n\n    this.matrix = []; // Matriz para almacenar los datos recibidos del servidor\n\n    this.row = 0; // Fila para la celda a actualizar\n\n    this.col = 0; // Columna para la celda a actualizar\n\n    this.val = 0; // Valor para la celda a actualizar\n\n    this.pla = 3; // Jugador para la celda a actualizar\n    // Otros métodos y funciones según sea necesario\n    // Front\n    // Variables para almacenar la posición activa\n\n    this.activeCell = null;\n    this.visitedCells = [];\n    this.isEnabled = true;\n  }\n\n  ngOnInit() {\n    // Configurar la conexión WebSocket al iniciar el componente\n    this.setupWebSocket(); // Solicitar la matriz al servidor al iniciar el componente\n\n    this.getMatrixValue();\n  } // Método para configurar la conexión WebSocket\n\n\n  setupWebSocket() {\n    const socket = this.websocketService.getMessage();\n    socket.subscribe(message => {\n      // Manejar los mensajes entrantes del servidor\n      this.handleIncomingMessage(message);\n    });\n  } // Método para manejar los mensajes entrantes del servidor\n  //\n  //\n\n\n  handleIncomingMessage(message) {\n    // Actualizar la matriz si se recibe un mensaje de actualización de matriz\n    if (message.action === 'updateMatrix') {\n      //Actualizar la matriz con los nuevos datos recibidos del servidor\n      this.matrix = message.data.matrix;\n    } // Otros tipos de mensajes pueden ser manejados aquí según las necesidades de la aplicación\n\n  } // Método para solicitar la matriz al servidor\n\n\n  getMatrixValue() {\n    this.websocketService.sendMessage('getMatrix', {});\n  } // Método para actualizar una celda en la matriz\n\n\n  updateCell(row, column, player, value) {\n    // Enviar un mensaje al servidor WebSocket (Controlador) para actualizar la celda\n    this.websocketService.sendMessage('updCell', {\n      row,\n      column,\n      player,\n      value\n    });\n  } // Método para actualizar VARIAS celda en la matrix cuando un juagador gana o pierde\n\n\n  updateCellsByPlayer(player, value, row, column) {\n    this.websocketService.sendMessage('updateCellsByPlayer', {\n      player,\n      value,\n      row,\n      column\n    });\n  } // Métodos que permiten \n  // cambia el color de acuerdocon el jugador que esté jugando\n\n\n  getCellColor(player) {\n    switch (player + '') {\n      case '1':\n        return 'blue';\n\n      case '2':\n        return 'red';\n\n      case '3':\n        return 'green';\n\n      case '4':\n        return 'gray';\n\n      default:\n        return 'lightblue';\n    }\n  }\n\n  handleKeyDown(event) {\n    if (this.isEnabled) {\n      console.log('aaaaaaaaaaaaaaaaaaaaaaaa');\n      let {\n        row,\n        col\n      } = this.activeCell || {\n        row: 0,\n        col: 0\n      };\n\n      switch (event.key) {\n        case 'ArrowUp':\n          row = Math.max(-1, row - 1);\n          break;\n\n        case 'ArrowDown':\n          row = Math.min(this.rows, row + 1);\n          break;\n\n        case 'ArrowLeft':\n          col = Math.max(-1, col - 1);\n          break;\n\n        case 'ArrowRight':\n          col = Math.min(this.cols, col + 1);\n          break;\n\n        default:\n          return;\n      }\n\n      if (row >= this.rows || col >= this.cols || row < 0 || col < 0) {\n        this.isEnabled = false;\n        this.updateCellsByPlayer(this.pla, null, this.rows, this.cols);\n      } else {\n        this.setActiveCell(row, col);\n      }\n    }\n  }\n\n  setActiveCell(row, col) {\n    this.activeCell = {\n      row,\n      col\n    };\n    this.visitedCells.push({\n      row,\n      col\n    });\n    this.updateCell(row, col, this.pla, 0);\n  }\n\n  isActiveCell(row, col) {\n    return this.activeCell?.row === row && this.activeCell?.col === col;\n  } // Otros métodos de prueba que se construyeron\n  // Método asincrónico para obtener el valor de una celda desde el servidor\n\n\n  getCellPlayer(row, column) {\n    var _this = this;\n\n    return _asyncToGenerator(function* () {\n      try {\n        const cellPlayer = yield _this.websocketService.sendMessage('getCellPlayer', {\n          row,\n          column\n        }); //console.log('Valor de la celda:', cellValue);\n\n        return cellPlayer;\n      } catch (error) {\n        console.error('Error obteniendo el valor de la celda:', error); // Aquí puedes manejar el error como desees\n\n        return null;\n      }\n    })();\n  } // Método para crear una nueva matriz en el servidor\n\n\n  createMatrix(row, column) {\n    // Enviar un mensaje al servidor WebSocket para crear la matriz\n    this.websocketService.sendMessage('createMatrix', {\n      row,\n      column\n    });\n  } // Método para DROP una nueva matriz en el servidor\n\n\n  dropMatrix(row, column) {\n    // Enviar un mensaje al servidor WebSocket para DROP la matriz\n    this.websocketService.sendMessage('dropMatrix', {});\n  }\n\n}\n\nMatrixComponent.ɵfac = function MatrixComponent_Factory(t) {\n  return new (t || MatrixComponent)(i0.ɵɵdirectiveInject(i1.WebsocketService));\n};\n\nMatrixComponent.ɵcmp = /*@__PURE__*/i0.ɵɵdefineComponent({\n  type: MatrixComponent,\n  selectors: [[\"app-matrix\"]],\n  decls: 16,\n  vars: 10,\n  consts: [[1, \"container\"], [1, \"update-cell-form\"], [\"type\", \"text\", \"placeholder\", \"Jugador\", 1, \"input-field\", 3, \"ngModel\", \"ngModelChange\"], [1, \"update-button\", 3, \"click\"], [\"tabindex\", \"0\", 1, \"scroll-container\"], [\"scrollContainer\", \"\"], [\"tabindex\", \"0\", 1, \"grid-container\", 3, \"keydown\"], [4, \"ngFor\", \"ngForOf\"], [\"class\", \"cell\", 3, \"left\", \"top\", \"background-color\", \"border\", \"width\", \"height\", \"click\", 4, \"ngFor\", \"ngForOf\"], [1, \"cell\", 3, \"click\"]],\n  template: function MatrixComponent_Template(rf, ctx) {\n    if (rf & 1) {\n      i0.ɵɵelementStart(0, \"div\", 0)(1, \"div\", 1)(2, \"label\");\n      i0.ɵɵtext(3, \"Jugador:\");\n      i0.ɵɵelementEnd();\n      i0.ɵɵelementStart(4, \"input\", 2);\n      i0.ɵɵlistener(\"ngModelChange\", function MatrixComponent_Template_input_ngModelChange_4_listener($event) {\n        return ctx.pla = $event;\n      });\n      i0.ɵɵelementEnd();\n      i0.ɵɵelementStart(5, \"button\", 3);\n      i0.ɵɵlistener(\"click\", function MatrixComponent_Template_button_click_5_listener() {\n        return ctx.createMatrix(ctx.rows, ctx.cols);\n      });\n      i0.ɵɵtext(6, \"Crear matrix\");\n      i0.ɵɵelementEnd();\n      i0.ɵɵelementStart(7, \"button\", 3);\n      i0.ɵɵlistener(\"click\", function MatrixComponent_Template_button_click_7_listener() {\n        return ctx.dropMatrix(ctx.rows, ctx.cols);\n      });\n      i0.ɵɵtext(8, \"Borrar matrix\");\n      i0.ɵɵelementEnd();\n      i0.ɵɵelementStart(9, \"button\", 3);\n      i0.ɵɵlistener(\"click\", function MatrixComponent_Template_button_click_9_listener() {\n        return ctx.getMatrixPlayer();\n      });\n      i0.ɵɵtext(10, \"Cargar matrix\");\n      i0.ɵɵelementEnd()();\n      i0.ɵɵelement(11, \"br\");\n      i0.ɵɵelementStart(12, \"div\", 4, 5)(14, \"div\", 6);\n      i0.ɵɵlistener(\"keydown\", function MatrixComponent_Template_div_keydown_14_listener($event) {\n        return ctx.handleKeyDown($event);\n      });\n      i0.ɵɵtemplate(15, MatrixComponent_div_15_Template, 2, 1, \"div\", 7);\n      i0.ɵɵelementEnd()()();\n    }\n\n    if (rf & 2) {\n      i0.ɵɵadvance(4);\n      i0.ɵɵproperty(\"ngModel\", ctx.pla);\n      i0.ɵɵadvance(8);\n      i0.ɵɵstyleProp(\"height\", ctx.windowHeight, \"px\")(\"padding\", ctx.sizebox * 6, \"px\");\n      i0.ɵɵadvance(2);\n      i0.ɵɵstyleProp(\"width\", ctx.sizebox * ctx.rows + 20, \"px\")(\"height\", ctx.sizebox * ctx.cols + 20, \"px\");\n      i0.ɵɵadvance(1);\n      i0.ɵɵproperty(\"ngForOf\", ctx.matrix);\n    }\n  },\n  dependencies: [i2.NgForOf, i3.DefaultValueAccessor, i3.NgControlStatus, i3.NgModel],\n  styles: [\".html[_ngcontent-%COMP%]   .body[_ngcontent-%COMP%]{\\r\\n  overflow: hidden;\\r\\n}\\r\\n\\r\\n.scroll-container[_ngcontent-%COMP%] {\\r\\n  width: 100%; \\r\\n  overflow: auto; \\r\\n  box-sizing: border-box; \\r\\n}\\r\\n\\r\\n.grid-container[_ngcontent-%COMP%] {\\r\\n  position: relative;\\r\\n}\\r\\n\\r\\n.cell[_ngcontent-%COMP%] {\\r\\n  border: 1px solid rgb(37, 37, 37);\\r\\n  display: inline-block;\\r\\n  text-align: center;\\r\\n  vertical-align: middle;\\r\\n  position: absolute;\\r\\n  z-index: 1;\\r\\n}\\r\\n\\r\\n.cell.active[_ngcontent-%COMP%] {\\r\\n  border: 2px solid rgb(248, 248, 246);\\r\\n  z-index: 2; \\r\\n}\\n/*# sourceMappingURL=data:application/json;base64,eyJ2ZXJzaW9uIjozLCJzb3VyY2VzIjpbIm1hdHJpeC5jb21wb25lbnQuY3NzIl0sIm5hbWVzIjpbXSwibWFwcGluZ3MiOiJBQUFBO0VBQ0UsZ0JBQWdCO0FBQ2xCOztBQUVBO0VBQ0UsV0FBVyxFQUFFLDJCQUEyQjtFQUN4QyxjQUFjLEVBQUUsK0JBQStCO0VBQy9DLHNCQUFzQjtBQUN4Qjs7QUFFQTtFQUNFLGtCQUFrQjtBQUNwQjs7QUFFQTtFQUNFLGlDQUFpQztFQUNqQyxxQkFBcUI7RUFDckIsa0JBQWtCO0VBQ2xCLHNCQUFzQjtFQUN0QixrQkFBa0I7RUFDbEIsVUFBVTtBQUNaOztBQUVBO0VBQ0Usb0NBQW9DO0VBQ3BDLFVBQVU7QUFDWiIsImZpbGUiOiJtYXRyaXguY29tcG9uZW50LmNzcyIsInNvdXJjZXNDb250ZW50IjpbIi5odG1sIC5ib2R5e1xyXG4gIG92ZXJmbG93OiBoaWRkZW47XHJcbn1cclxuXHJcbi5zY3JvbGwtY29udGFpbmVyIHtcclxuICB3aWR0aDogMTAwJTsgLyogbyBlbCB0YW1hw7FvIHF1ZSBkZXNlZXMgKi9cclxuICBvdmVyZmxvdzogYXV0bzsgLyogSGFiaWxpdGEgZWwgZGVzcGxhemFtaWVudG8gKi9cclxuICBib3gtc2l6aW5nOiBib3JkZXItYm94OyBcclxufVxyXG5cclxuLmdyaWQtY29udGFpbmVyIHtcclxuICBwb3NpdGlvbjogcmVsYXRpdmU7XHJcbn1cclxuXHJcbi5jZWxsIHtcclxuICBib3JkZXI6IDFweCBzb2xpZCByZ2IoMzcsIDM3LCAzNyk7XHJcbiAgZGlzcGxheTogaW5saW5lLWJsb2NrO1xyXG4gIHRleHQtYWxpZ246IGNlbnRlcjtcclxuICB2ZXJ0aWNhbC1hbGlnbjogbWlkZGxlO1xyXG4gIHBvc2l0aW9uOiBhYnNvbHV0ZTtcclxuICB6LWluZGV4OiAxO1xyXG59XHJcblxyXG4uY2VsbC5hY3RpdmUge1xyXG4gIGJvcmRlcjogMnB4IHNvbGlkIHJnYigyNDgsIDI0OCwgMjQ2KTtcclxuICB6LWluZGV4OiAyOyBcclxufVxyXG4iXX0= */\"]\n});","map":{"version":3,"mappings":"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","names":["i0","i_r3","ctx_r4","MatrixComponent","constructor","websocketService","ngOnInit","setupWebSocket","getMatrixValue","socket","getMessage","subscribe","message","handleIncomingMessage","action","matrix","data","sendMessage","updateCell","row","column","player","value","updateCellsByPlayer","getCellColor","handleKeyDown","event","isEnabled","console","log","col","activeCell","key","Math","max","min","rows","cols","pla","setActiveCell","visitedCells","push","isActiveCell","getCellPlayer","cellPlayer","error","createMatrix","dropMatrix","selectors","decls","vars","consts","template","ctx"],"sourceRoot":"","sources":["C:\\kmi\\Dropbox\\pro\\matrix - copia\\front\\matrix\\src\\app\\components\\matrix\\matrix.component.html","C:\\kmi\\Dropbox\\pro\\matrix - copia\\front\\matrix\\src\\app\\components\\matrix\\matrix.component.ts"],"sourcesContent":["\n<div class=\"container\">\n  \n  <div class=\"update-cell-form\">\n    <label>Jugador:</label>\n    <input class=\"input-field\" type=\"text\" placeholder=\"Jugador\" [(ngModel)]=\"pla\">\n    <button class=\"update-button\" (click)=\"createMatrix(rows, cols)\">Crear matrix</button>\n    <button class=\"update-button\" (click)=\"dropMatrix(rows, cols)\">Borrar matrix</button>\n    <button class=\"update-button\" (click)=\"getMatrixPlayer()\">Cargar matrix</button>\n  </div>\n  <br>\n  <div class=\"scroll-container\" #scrollContainer tabindex=\"0\" [style.height.px]=\"windowHeight\" [style.padding.px]=\"sizebox * 6\">\n  <div (keydown)=\"handleKeyDown($event)\" tabindex=\"0\" class=\"grid-container\" [style.width.px]=\"sizebox * rows +20\" [style.height.px]=\" sizebox *cols +20\">\n    <div *ngFor=\"let row of matrix; let i = index\">\n      <div *ngFor=\"let cell of row; let j = index\"\n           [style.left]=\"j * sizebox + 'px'\" \n           [style.top]=\"i * sizebox + 'px'\"\n           [style.background-color]=\"isActiveCell(i, j) ? getCellColor(pla) : getCellColor(cell?.player)\"\n           [style.border]=\"isActiveCell(i, j) ? '2px solid yellow' : ''\"\n           [style.width.px]=\"sizebox -1\"\n           [style.height.px]=\"sizebox -1\"\n           class=\"cell\"\n           (click)=\"setActiveCell(i, j)\">\n        {{''}}\n      </div>\n    </div>\n  </div>\n  </div>\n  </div>\n  ","import { Component, OnInit } from '@angular/core';\nimport { WebsocketService } from '../../services/websocket.service';\n\n@Component({\n  selector: 'app-matrix',\n  templateUrl: './matrix.component.html',\n  styleUrls: ['./matrix.component.css']\n})\nexport class MatrixComponent implements OnInit {\n  // Declarar propiedades y métodos según sea necesario\n\n  rows: number = 60; // Fila para la celda a actualizar\n  cols: number = 60; // Columna para la celda a actualizar\n  matrix: any[][] = []; // Matriz para almacenar los datos recibidos del servidor\n  row: number = 0; // Fila para la celda a actualizar\n  col: number = 0; // Columna para la celda a actualizar\n  val: number = 0; // Valor para la celda a actualizar\n  pla: number = 3; // Jugador para la celda a actualizar\n\n\n\n  constructor(private websocketService: WebsocketService) { }\n\n  ngOnInit(): void {\n    // Configurar la conexión WebSocket al iniciar el componente\n    this.setupWebSocket();\n    // Solicitar la matriz al servidor al iniciar el componente\n    this.getMatrixValue();\n  }\n\n  // Método para configurar la conexión WebSocket\n  private setupWebSocket(): void {\n    const socket = this.websocketService.getMessage();\n    socket.subscribe((message) => {\n      // Manejar los mensajes entrantes del servidor\n      this.handleIncomingMessage(message);\n    });\n  }\n\n  // Método para manejar los mensajes entrantes del servidor\n  //\n  //\n  private handleIncomingMessage(message: any): void {\n    // Actualizar la matriz si se recibe un mensaje de actualización de matriz\n    if (message.action === 'updateMatrix') {\n      //Actualizar la matriz con los nuevos datos recibidos del servidor\n      this.matrix = message.data.matrix;\n    }\n\n    // Otros tipos de mensajes pueden ser manejados aquí según las necesidades de la aplicación\n  }\n\n\n  // Método para solicitar la matriz al servidor\n  getMatrixValue(): void {\n    this.websocketService.sendMessage('getMatrix', {});\n  }\n\n  // Método para actualizar una celda en la matriz\n  updateCell(row: number, column: number, player: number, value: number): void {\n    // Enviar un mensaje al servidor WebSocket (Controlador) para actualizar la celda\n    this.websocketService.sendMessage('updCell', { row, column, player, value });\n  }\n\n  // Método para actualizar VARIAS celda en la matrix cuando un juagador gana o pierde\n  updateCellsByPlayer(player: number, value: number | null, row: number, column: number) {\n    this.websocketService.sendMessage('updateCellsByPlayer', { player, value, row, column });\n  }\n\n\n\n\n\n  // Otros métodos y funciones según sea necesario\n  // Front\n  // Variables para almacenar la posición activa\n  activeCell: { row: number, col: number } | null = null;\n  visitedCells: { row: number, col: number }[] = [];\n  isEnabled: boolean = true;\n\n\n  // Métodos que permiten \n  // cambia el color de acuerdocon el jugador que esté jugando\n  getCellColor(player: number | null): any {\n    switch (player + '') {\n      case '1':\n        return 'blue';\n      case '2':\n        return 'red';\n      case '3':\n        return 'green';\n      case '4':\n        return 'gray';\n      default:\n        return 'lightblue';\n    }\n  }\n\n\n  handleKeyDown(event: KeyboardEvent): void {\n    if (this.isEnabled) {\n      console.log('aaaaaaaaaaaaaaaaaaaaaaaa');\n      let { row, col } = this.activeCell || { row: 0, col: 0 };\n      switch (event.key) {\n        case 'ArrowUp':\n          row = Math.max(-1, row - 1);\n          break;\n        case 'ArrowDown':\n          row = Math.min(this.rows, row + 1);\n          break;\n        case 'ArrowLeft':\n          col = Math.max(-1, col - 1);\n          break;\n        case 'ArrowRight':\n          col = Math.min(this.cols, col + 1);\n          break;\n        default:\n          return;\n      }\n      if (row >= this.rows || col >= this.cols || row < 0 || col < 0) {\n        this.isEnabled = false;\n        this.updateCellsByPlayer(this.pla, null, this.rows, this.cols);\n\n      } else {\n        this.setActiveCell(row, col);\n      }\n    }\n  }\n\n  setActiveCell(row: number, col: number): void {\n    this.activeCell = { row, col };\n    this.visitedCells.push({ row, col });\n    this.updateCell(row, col, this.pla, 0);\n  }\n  isActiveCell(row: number, col: number): boolean {\n    return this.activeCell?.row === row && this.activeCell?.col === col;\n  }\n\n\n\n\n\n\n\n\n\n\n\n  // Otros métodos de prueba que se construyeron\n  // Método asincrónico para obtener el valor de una celda desde el servidor\n  async getCellPlayer(row: number, column: number): Promise<any> {\n    try {\n      const cellPlayer = await this.websocketService.sendMessage('getCellPlayer', { row, column });\n      //console.log('Valor de la celda:', cellValue);\n      return cellPlayer;\n    } catch (error) {\n      console.error('Error obteniendo el valor de la celda:', error);\n      // Aquí puedes manejar el error como desees\n      return null;\n    }\n  }\n\n  // Método para crear una nueva matriz en el servidor\n  createMatrix(row: number, column: number): void {\n    // Enviar un mensaje al servidor WebSocket para crear la matriz\n    this.websocketService.sendMessage('createMatrix', { row, column });\n  }\n\n  // Método para DROP una nueva matriz en el servidor\n  dropMatrix(row: number, column: number): void {\n    // Enviar un mensaje al servidor WebSocket para DROP la matriz\n    this.websocketService.sendMessage('dropMatrix', {});\n  }\n\n}\n"]},"metadata":{},"sourceType":"module"}