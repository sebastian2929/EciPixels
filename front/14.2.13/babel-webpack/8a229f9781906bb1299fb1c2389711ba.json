{"ast":null,"code":"import _asyncToGenerator from \"C:/kmi/Dropbox/pro/matrix - copia/front/matrix/node_modules/@babel/runtime/helpers/esm/asyncToGenerator.js\";\nimport { ElementRef } from '@angular/core';\nimport * as i0 from \"@angular/core\";\nconst _c0 = [\"scrollContainer\"];\nconst _c1 = [\"canvas\"];\n\nclass Cell {\n  constructor(color) {\n    this.color = color;\n  }\n\n}\n\nexport class MatrixComponent {\n  constructor() {\n    this.rows = 50;\n    this.cols = 50;\n    this.pla = 2;\n    this.matrix = [];\n    this.paintIntervalDuration = 100;\n    this.paintDelay = 3;\n    this.windowWidth = window.innerWidth;\n    this.windowHeight = window.innerHeight;\n    this.cellSize = this.windowWidth / (this.rows + 1);\n    this.canvasContext = null;\n    this.activeCell = {\n      row: 0,\n      col: 0\n    };\n    this.prevCell = {\n      row: 0,\n      col: 0\n    };\n  }\n\n  ngOnInit() {\n    window.addEventListener('keydown', this.handleKeyDown.bind(this));\n  }\n\n  ngAfterViewInit() {\n    this.canvasContext = this.canvas.nativeElement.getContext('2d');\n\n    if (this.canvasContext) {\n      this.canvas.nativeElement.width = this.rows * this.cellSize;\n      this.canvas.nativeElement.height = this.cols * this.cellSize;\n      console.log('Ancho del canvas:', this.canvas.nativeElement.width);\n      console.log('Alto del canvas:', this.canvas.nativeElement.height);\n      this.initMatrix();\n      this.setRandomStartCell();\n      this.paintMatrix();\n      this.moveScroll();\n    }\n  }\n\n  ngOnDestroy() {\n    clearInterval(this.paintInterval);\n    window.removeEventListener('keydown', this.handleKeyDown.bind(this));\n  }\n\n  initMatrix() {\n    for (let i = 0; i < this.rows; i++) {\n      this.matrix[i] = [];\n\n      for (let j = 0; j < this.cols; j++) {\n        this.matrix[i][j] = new Cell('gray');\n      }\n    }\n  }\n\n  paintMatrix() {\n    for (let i = 0; i < this.rows; i++) {\n      for (let j = 0; j < this.cols; j++) {\n        const x = j * this.cellSize;\n        const y = i * this.cellSize; // Dibuja el borde de la celda\n\n        this.canvasContext.strokeStyle = 'black'; // Color del borde\n\n        this.canvasContext.lineWidth = 1; // Grosor del borde\n\n        this.canvasContext.strokeRect(x, y, this.cellSize, this.cellSize); // Rellena la celda con el color correspondiente\n\n        this.canvasContext.fillStyle = this.matrix[i][j].color;\n        this.canvasContext.fillRect(x, y, this.cellSize, this.cellSize);\n      }\n    }\n  }\n\n  setRandomStartCell() {\n    let row = Math.floor(Math.random() * (this.rows - 8)) + 4;\n    let col = Math.floor(Math.random() * (this.cols - 8)) + 4;\n\n    for (let i = row - 1; i <= row + 1; i++) {\n      for (let j = col - 1; j <= col + 1; j++) {\n        this.matrix[i][j].color = this.getPlayerColor(this.pla);\n      }\n    }\n\n    this.activeCell = {\n      row,\n      col\n    };\n    this.paintCell();\n  }\n\n  handleKeyDown(event) {\n    event.preventDefault();\n    clearInterval(this.paintInterval);\n    const directionMap = {\n      'ArrowUp': [-1, 0],\n      'ArrowDown': [1, 0],\n      'ArrowLeft': [0, -1],\n      'ArrowRight': [0, 1]\n    };\n    const direction = directionMap[event.key];\n\n    if (direction) {\n      this.move(direction[0], direction[1]);\n      this.paintInterval = setInterval(() => {\n        this.move(direction[0], direction[1]);\n      }, this.paintIntervalDuration);\n    }\n  }\n\n  move(rowDelta, colDelta) {\n    const nRow = this.activeCell.row + rowDelta;\n    const nCol = this.activeCell.col + colDelta;\n\n    if (nRow >= 0 && nRow < this.rows && nCol >= 0 && nCol < this.cols) {\n      this.paintCell();\n      this.activeCell = {\n        row: nRow,\n        col: nCol\n      };\n    } else {\n      clearInterval(this.paintInterval);\n    }\n  }\n\n  paintCell() {\n    const {\n      row,\n      col\n    } = this.activeCell; // Obtener el color del jugador\n\n    const playerColor = this.getPlayerColor(this.pla); // Retrasar el pintado de las celdas utilizando un temporizador\n    // Ajusta este valor según sea necesario\n\n    let currentRow = row * this.cellSize;\n    let currentCol = col * this.cellSize;\n    const paintInterval = setInterval(() => {\n      // Llenar una fila de píxeles\n      for (let j = currentCol; j < (col + 1) * this.cellSize; j++) {\n        this.canvasContext.fillStyle = playerColor;\n        this.canvasContext.fillRect(j, currentRow, 1, 1); // Mover el scroll\n\n        this.moveScroll();\n      }\n\n      currentRow++; // Si hemos pintado todas las filas de la celda, detener el temporizador\n\n      if (currentRow >= (row + 1) * this.cellSize) {\n        clearInterval(paintInterval); // Si la celda anterior también pertenece al jugador, llenarla nuevamente\n\n        const {\n          row: prow,\n          col: pcol\n        } = this.prevCell;\n\n        if (this.matrix[prow][pcol].color === this.getPlayerColor(this.pla)) {\n          this.matrix[prow][pcol].color = this.getPlayerColor(this.pla);\n        } // Actualizar la celda previa\n\n\n        this.prevCell = this.activeCell;\n      }\n    }, this.paintDelay);\n  }\n\n  moveScroll() {\n    var _this = this;\n\n    return _asyncToGenerator(function* () {\n      if (_this.scrollContainer !== null) {\n        const targetTop = _this.cellSize * _this.activeCell.row - _this.windowHeight / 2 + 32;\n        const targetLeft = _this.cellSize * _this.activeCell.col - _this.windowWidth / 2 + 32;\n\n        _this.scrollContainer.nativeElement.scrollTo({\n          top: targetTop,\n          left: targetLeft,\n          behavior: 'smooth' // Establece la transición suave\n\n        });\n      }\n    })();\n  }\n\n  getPlayerColor(player) {\n    switch (player + '') {\n      case '1':\n        return 'blue';\n\n      case '2':\n        return 'salmon';\n\n      case '3':\n        return 'green';\n\n      case '4':\n        return 'yellow';\n\n      case '5':\n        return 'pink';\n    }\n  }\n\n}\n\nMatrixComponent.ɵfac = function MatrixComponent_Factory(t) {\n  return new (t || MatrixComponent)();\n};\n\nMatrixComponent.ɵcmp = /*@__PURE__*/i0.ɵɵdefineComponent({\n  type: MatrixComponent,\n  selectors: [[\"app-matrix\"]],\n  viewQuery: function MatrixComponent_Query(rf, ctx) {\n    if (rf & 1) {\n      i0.ɵɵviewQuery(_c0, 5);\n      i0.ɵɵviewQuery(_c1, 5);\n    }\n\n    if (rf & 2) {\n      let _t;\n\n      i0.ɵɵqueryRefresh(_t = i0.ɵɵloadQuery()) && (ctx.scrollContainer = _t.first);\n      i0.ɵɵqueryRefresh(_t = i0.ɵɵloadQuery()) && (ctx.canvas = _t.first);\n    }\n  },\n  decls: 5,\n  vars: 6,\n  consts: [[\"tabindex\", \"0\", 1, \"scroll-container\"], [\"scrollContainer\", \"\"], [1, \"scroll-content\"], [\"tabindex\", \"0\", 1, \"grid-container\"], [\"canvas\", \"\"]],\n  template: function MatrixComponent_Template(rf, ctx) {\n    if (rf & 1) {\n      i0.ɵɵelementStart(0, \"div\", 0, 1)(2, \"div\", 2);\n      i0.ɵɵelement(3, \"canvas\", 3, 4);\n      i0.ɵɵelementEnd()();\n    }\n\n    if (rf & 2) {\n      i0.ɵɵstyleProp(\"height\", ctx.windowHeight, \"px\")(\"width\", ctx.windowWidth, \"px\");\n      i0.ɵɵadvance(3);\n      i0.ɵɵstyleProp(\"width\", ctx.cellSize * ctx.rows + 20, \"px\");\n    }\n  },\n  styles: [\".html[_ngcontent-%COMP%]   .body[_ngcontent-%COMP%]{\\r\\n  overflow: hidden;\\r\\n}\\r\\n\\r\\n.scroll-container[_ngcontent-%COMP%] {\\r\\n  padding: 200px; \\r\\n  width: 100%; \\r\\n  overflow: scroll; \\r\\n  box-sizing: border-box;\\r\\n  background-color: blue;\\r\\n  text-align: center; \\r\\n}\\r\\n\\r\\n.scroll-content[_ngcontent-%COMP%] {\\r\\n  display: inline-block; \\r\\n  vertical-align: middle; \\r\\n}\\r\\n\\r\\n.grid-container[_ngcontent-%COMP%] {\\r\\n  background-color: rgb(189, 15, 15);\\r\\n}\\r\\n\\r\\n.row[_ngcontent-%COMP%] {\\r\\n  display: flex; \\r\\n}\\r\\n\\r\\n.cell[_ngcontent-%COMP%] {\\r\\n  border: 2px solid #555555; \\r\\n  transition: background-color 0.5s ease; \\r\\n}\\n/*# sourceMappingURL=data:application/json;base64,eyJ2ZXJzaW9uIjozLCJzb3VyY2VzIjpbIm1hdHJpeC5jb21wb25lbnQuY3NzIl0sIm5hbWVzIjpbXSwibWFwcGluZ3MiOiJBQUFBO0VBQ0UsZ0JBQWdCO0FBQ2xCOztBQUVBO0VBQ0UsY0FBYyxFQUFFLCtCQUErQjtFQUMvQyxXQUFXLEVBQUUsMkJBQTJCO0VBQ3hDLGdCQUFnQixFQUFFLCtCQUErQjtFQUNqRCxzQkFBc0I7RUFDdEIsc0JBQXNCO0VBQ3RCLGtCQUFrQixFQUFFLHdDQUF3QztBQUM5RDs7QUFFQTtFQUNFLHFCQUFxQixFQUFFLHdEQUF3RDtFQUMvRSxzQkFBc0IsRUFBRSxzQ0FBc0M7QUFDaEU7O0FBQ0E7RUFDRSxrQ0FBa0M7QUFDcEM7O0FBRUE7RUFDRSxhQUFhLEVBQUUsNkNBQTZDO0FBQzlEOztBQUVBO0VBQ0UseUJBQXlCLEVBQUUsc0JBQXNCO0VBQ2pELHNDQUFzQyxFQUFFLGtDQUFrQztBQUM1RSIsImZpbGUiOiJtYXRyaXguY29tcG9uZW50LmNzcyIsInNvdXJjZXNDb250ZW50IjpbIi5odG1sIC5ib2R5e1xyXG4gIG92ZXJmbG93OiBoaWRkZW47XHJcbn1cclxuXHJcbi5zY3JvbGwtY29udGFpbmVyIHtcclxuICBwYWRkaW5nOiAyMDBweDsgLyogUGFkZGluZyBlbiB0b2RvcyBsb3MgbGFkb3MgKi9cclxuICB3aWR0aDogMTAwJTsgLyogbyBlbCB0YW1hw7FvIHF1ZSBkZXNlZXMgKi9cclxuICBvdmVyZmxvdzogc2Nyb2xsOyAvKiBIYWJpbGl0YSBlbCBkZXNwbGF6YW1pZW50byAqL1xyXG4gIGJveC1zaXppbmc6IGJvcmRlci1ib3g7XHJcbiAgYmFja2dyb3VuZC1jb2xvcjogYmx1ZTtcclxuICB0ZXh0LWFsaWduOiBjZW50ZXI7IC8qIENlbnRyYSBob3Jpem9udGFsbWVudGUgZWwgY29udGVuaWRvICovXHJcbn1cclxuXHJcbi5zY3JvbGwtY29udGVudCB7XHJcbiAgZGlzcGxheTogaW5saW5lLWJsb2NrOyAvKiBQZXJtaXRlIHF1ZSBlbCBjb250ZW5lZG9yIHNlIGNlbnRyZSBob3Jpem9udGFsbWVudGUgKi9cclxuICB2ZXJ0aWNhbC1hbGlnbjogbWlkZGxlOyAvKiBDZW50cmEgdmVydGljYWxtZW50ZSBlbCBjb250ZW5pZG8gKi9cclxufVxyXG4uZ3JpZC1jb250YWluZXIge1xyXG4gIGJhY2tncm91bmQtY29sb3I6IHJnYigxODksIDE1LCAxNSk7XHJcbn1cclxuXHJcbi5yb3cge1xyXG4gIGRpc3BsYXk6IGZsZXg7IC8qIFBhcmEgcXVlIGxhcyBjZWxkYXMgc2UgbXVlc3RyZW4gZW4gbMOtbmVhICovXHJcbn1cclxuXHJcbi5jZWxsIHtcclxuICBib3JkZXI6IDJweCBzb2xpZCAjNTU1NTU1OyAvKiBCb3JkZSBkZSBsYSBjZWxkYSAqL1xyXG4gIHRyYW5zaXRpb246IGJhY2tncm91bmQtY29sb3IgMC41cyBlYXNlOyAvKiBUcmFuc2ljacOzbiBkZWwgY29sb3IgZGUgZm9uZG8gKi9cclxufVxyXG5cclxuIl19 */\"]\n});","map":{"version":3,"mappings":"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","names":["ElementRef","Cell","constructor","color","MatrixComponent","window","innerWidth","innerHeight","windowWidth","rows","activeCell","row","col","prevCell","ngOnInit","addEventListener","handleKeyDown","bind","ngAfterViewInit","canvasContext","canvas","nativeElement","getContext","width","cellSize","height","cols","console","log","initMatrix","setRandomStartCell","paintMatrix","moveScroll","ngOnDestroy","clearInterval","paintInterval","removeEventListener","i","matrix","j","x","y","strokeStyle","lineWidth","strokeRect","fillStyle","fillRect","Math","floor","random","getPlayerColor","pla","paintCell","event","preventDefault","directionMap","direction","key","move","setInterval","paintIntervalDuration","rowDelta","colDelta","nRow","nCol","playerColor","currentRow","currentCol","prow","pcol","paintDelay","scrollContainer","targetTop","windowHeight","targetLeft","scrollTo","top","left","behavior","player","selectors","viewQuery","i0","ctx"],"sourceRoot":"","sources":["C:\\kmi\\Dropbox\\pro\\matrix - copia\\front\\matrix\\src\\app\\components\\matrix\\matrix.component.ts","C:\\kmi\\Dropbox\\pro\\matrix - copia\\front\\matrix\\src\\app\\components\\matrix\\matrix.component.html"],"sourcesContent":["import { Component, OnInit } from '@angular/core';\nimport { ViewChild, ElementRef } from '@angular/core';\n\nclass Cell {\n  constructor(public color: string) { }\n}\n\n@Component({\n  selector: 'app-matrix',\n  templateUrl: './matrix.component.html',\n  styleUrls: ['./matrix.component.css']\n})\n\nexport class MatrixComponent implements OnInit {\n  @ViewChild('scrollContainer') scrollContainer!: ElementRef;\n  @ViewChild('canvas') canvas!: ElementRef<HTMLCanvasElement>;\n\n  rows: number = 50;\n  cols: number = 50;\n  pla: number = 2;\n\n  matrix: Cell[][] = [];\n  activeCell: { row: number, col: number };\n  prevCell: { row: number, col: number };\n  paintInterval: any;\n  paintIntervalDuration: number = 100;\n  paintDelay = 3;\n\n  windowWidth: number = window.innerWidth;\n  windowHeight: number = window.innerHeight;\n  cellSize: number = this.windowWidth / (this.rows + 1);\n  canvasContext: CanvasRenderingContext2D | null = null;\n\n  constructor() {\n    this.activeCell = { row: 0, col: 0 };\n    this.prevCell = { row: 0, col: 0 };\n  }\n\n  ngOnInit(): void {\n    window.addEventListener('keydown', this.handleKeyDown.bind(this));\n  }\n\n  ngAfterViewInit(): void {\n    this.canvasContext = this.canvas.nativeElement.getContext('2d');\n    if (this.canvasContext) {\n      this.canvas.nativeElement.width = this.rows * this.cellSize;\n      this.canvas.nativeElement.height = this.cols * this.cellSize;\n      console.log('Ancho del canvas:', this.canvas.nativeElement.width);\n      console.log('Alto del canvas:', this.canvas.nativeElement.height);\n      this.initMatrix();\n      this.setRandomStartCell();\n      this.paintMatrix();\n      this.moveScroll();\n    }\n  }\n\n  ngOnDestroy() {\n    clearInterval(this.paintInterval);\n    window.removeEventListener('keydown', this.handleKeyDown.bind(this));\n  }\n\n\n  initMatrix(): void {\n    for (let i = 0; i < this.rows; i++) {\n      this.matrix[i] = [];\n      for (let j = 0; j < this.cols; j++) {\n        this.matrix[i][j] = new Cell('gray');\n      }\n    }\n  }\n\n  paintMatrix(): void {\n    for (let i = 0; i < this.rows; i++) {\n      for (let j = 0; j < this.cols; j++) {\n        const x = j * this.cellSize;\n        const y = i * this.cellSize;\n        // Dibuja el borde de la celda\n        this.canvasContext!.strokeStyle = 'black'; // Color del borde\n        this.canvasContext!.lineWidth = 1; // Grosor del borde\n        this.canvasContext!.strokeRect(x, y, this.cellSize, this.cellSize);\n        // Rellena la celda con el color correspondiente\n        this.canvasContext!.fillStyle = this.matrix[i][j].color;\n        this.canvasContext!.fillRect(x, y, this.cellSize, this.cellSize);\n      }\n    }\n  }\n\n\n  setRandomStartCell(): void {\n    let row = Math.floor(Math.random() * (this.rows - 8)) + 4;\n    let col = Math.floor(Math.random() * (this.cols - 8)) + 4;\n    for (let i = row - 1; i <= row + 1; i++) {\n      for (let j = col - 1; j <= col + 1; j++) {\n        this.matrix[i][j].color = this.getPlayerColor(this.pla);\n      }\n    }\n    this.activeCell = { row, col };\n    this.paintCell();\n  }\n\n  handleKeyDown(event: KeyboardEvent): void {\n    event.preventDefault();\n    clearInterval(this.paintInterval);\n    const directionMap: { [key: string]: [number, number] } = {\n      'ArrowUp': [-1, 0],\n      'ArrowDown': [1, 0],\n      'ArrowLeft': [0, -1],\n      'ArrowRight': [0, 1]\n    };\n    const direction = directionMap[event.key];\n    if (direction) {\n      this.move(direction[0], direction[1]);\n      this.paintInterval = setInterval(() => {\n        this.move(direction[0], direction[1]);\n      }, this.paintIntervalDuration);\n    }\n  }\n\n  move(rowDelta: number, colDelta: number): void {\n    const nRow = this.activeCell.row + rowDelta;\n    const nCol = this.activeCell.col + colDelta;\n    if (nRow >= 0 && nRow < this.rows && nCol >= 0 && nCol < this.cols) {\n      this.paintCell();\n      this.activeCell = { row: nRow, col: nCol };\n    } else {\n      clearInterval(this.paintInterval);\n    }\n  }\n\n\n\n\n  paintCell(): void {\n    const { row, col } = this.activeCell;\n\n    // Obtener el color del jugador\n    const playerColor = this.getPlayerColor(this.pla);\n\n    // Retrasar el pintado de las celdas utilizando un temporizador\n     // Ajusta este valor según sea necesario\n    let currentRow = row * this.cellSize;\n    let currentCol = col * this.cellSize;\n\n    const paintInterval = setInterval(() => {\n      // Llenar una fila de píxeles\n      for (let j = currentCol; j < (col + 1) * this.cellSize; j++) {\n        this.canvasContext!.fillStyle = playerColor;\n        this.canvasContext!.fillRect(j, currentRow, 1, 1);\n        // Mover el scroll\n        this.moveScroll();\n      }\n      currentRow++;\n\n      // Si hemos pintado todas las filas de la celda, detener el temporizador\n      if (currentRow >= (row + 1) * this.cellSize) {\n        clearInterval(paintInterval);\n\n        // Si la celda anterior también pertenece al jugador, llenarla nuevamente\n        const { row: prow, col: pcol } = this.prevCell;\n        if (this.matrix[prow][pcol].color === this.getPlayerColor(this.pla)) {\n          this.matrix[prow][pcol].color = this.getPlayerColor(this.pla);\n        }\n\n        // Actualizar la celda previa\n        this.prevCell = this.activeCell;\n\n      }\n    }, this.paintDelay);\n  }\n\n  async moveScroll() {\n    if (this.scrollContainer !== null) {\n      const targetTop = (this.cellSize * this.activeCell.row) - (this.windowHeight / 2) + 32;\n      const targetLeft = (this.cellSize * this.activeCell.col) - (this.windowWidth / 2) + 32;\n  \n      this.scrollContainer.nativeElement.scrollTo({\n        top: targetTop,\n        left: targetLeft,\n        behavior: 'smooth' // Establece la transición suave\n      });\n    }\n  }\n  \n  \n  getPlayerColor(player: number | null): any {\n    switch (player + '') {\n      case '1':\n        return 'blue';\n      case '2':\n        return 'salmon';\n      case '3':\n        return 'green';\n      case '4':\n        return 'yellow';\n      case '5':\n        return 'pink';\n    }\n  }\n}\n","<div class=\"scroll-container\" #scrollContainer tabindex=\"0\" [style.height.px]=\"windowHeight\"\n  [style.width.px]=\"windowWidth\">\n  <div class=\"scroll-content\">\n    <canvas #canvas tabindex=\"0\" class=\"grid-container\" [style.width.px]=\"cellSize * rows + 20\"></canvas>\n  </div>\n</div>"]},"metadata":{},"sourceType":"module"}